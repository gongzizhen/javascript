/***
 *  es6 规范 新增一项内存管理优化机制,尾调用优化
 *
 *  什么是尾调用优化?
 *    就是指某个函数的最后一步是调用另一个函数
 */
// 尾调用 函数 f() 最后一步调用函数 g() ,这就是尾调用
function f() {
    return g();
};
/***
 * 在 es6之前,执行这段代码存在如下操作
 *  1. 执行到 f 函数体,第一个栈帧被推到栈上.
 *  2. 执行 函数 f 的函数体,到return 语句. 返回值必须先执行 g 函数;
 *  3. 执行到 g 函数体,第二个栈帧被推栈上.
 *  4. 执行 g 函数体,计算出返回值,
 *  5. 执行完g 函数 在栈中弹出 第二次进入的栈帧
 *  6. 到 函数 f 函数体 返回 返回值;
 *  7. 将函数 f 栈帧弹出执行栈
 * 
 *  在es6 优化之后,执行 f函数存在以下步骤
 *  1. 执行到 f 函数体,第一个栈帧被推到栈上.
 *  2. 执行 函数 f 的函数体,到return 语句. 返回值必须先执行 g 函数;
 *  3. js引擎发现第一个栈帧弹出栈外也没有问题,因为 函数g的返回值,也是函数f的返回值
 *  4.弹出函数f的栈帧
 *  5.执行到函数g的函数体,栈帧被推到栈上;
 *  6.执行 函数g的函数体,计算其返回值,并返回;
 *  7.将 函数 g 的栈帧弹出栈外;
 * 
 *  es6 之前,每多调用一次嵌套函数,就会多增加一个栈帧.
 *  而es6优化后,无论调用多次嵌套函数,都只有一个栈帧.
 *  
 * 尾调用时函数的最后一步操作,所以不需要保留外层函数的调用记录,
 *  因为调用位置,内部变量等信息都不会在用到了,已经保存到尾函数体内;
 *  只要直接用内层函数的执行栈帧,取代外层函数的执行栈帧.
 */

/***
 *  尾调用优化的条件
 *  尾调用优化条件就是确定外部函数栈帧帧的没有必要存在了. 条件如下:
 *   1. 必须在严格模式下执行;
 *   2. 外部函数的返回值是对尾调用函数的调用
 *   3. 尾调用函数返回后不需要执行额外的逻辑
 *   4. 尾调用函数引用外部函数作用域中自由变量的闭包
 */
// 以下都是违反了上述条件的函数,因此都不符合尾调用优化
'use strict'
/***
 *  // 没有优化,尾调用函数没有返回;
 *   function f() {
 *       g()
 *   }
 *  没有优化,尾巴调用函数没有直接返回
 *   function f() {
 *      let y = g();
 *      return y
 *    }
 *  没有优化,因为尾函数调用后还有其它操作;
 *  function f(x) {
 *     return g(x) + 1;
 *   }
 *  没有优化,尾函数是个闭包
 function f(x) {
    function g(x) {
        return x;
    }
    return g(x)
}
 */

// 下面是几个符合尾调用优化的例子
// 符合,f1栈帧销毁前执行参数计算
function f1(a, b) {
    return g1(a + b)
}
// 符合,初始返回值 a 不涉及栈帧
function f2(a,b) {
    if(a < b) {
        return a;
    }
    return g2(a + b)
};
// 尾部函数不一定出现在函数的尾部,只要是最后一步操作即可
function f3(x) {
    if(x > 0) {
        return m(x)
    }
    return n(x);
};
// 上面代码, 函数 m 和 n 都属于尾调用,因为他们都是函数f3的最后一步;


